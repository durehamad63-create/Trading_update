<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading AI - Charts & Trends</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .controls { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .chart-container { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .chart-wrapper { position: relative; height: 400px; }
        .trends-wrapper { position: relative; height: 300px; }
        input, select, button { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }
        button { background: #007bff; color: white; cursor: pointer; }
        button:hover { background: #0056b3; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .admin-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .admin-btn { background: #28a745; }
        .admin-btn.danger { background: #dc3545; }
        .admin-btn:hover { opacity: 0.9; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Trading AI Platform - Charts & Trends</h1>
        
        <div class="controls">
            <select id="environmentSelect" onchange="updateEnvironment()">
                <option value="localhost">Localhost</option>
                <option value="railway">Railway (Production)</option>
            </select>
            <input type="text" id="symbolInput" placeholder="Enter symbol (e.g., BTC, NVDA)" value="BTC">
            <select id="timeframeSelect">
                <option value="1h">1 Hour</option>
                <option value="4H">4 Hours</option>
                <option value="1D" selected>1 Day</option>
                <option value="7D">7 Days</option>
                <option value="1W">1 Week</option>
                <option value="1M">1 Month</option>
            </select>
            <button onclick="loadChart()">Load Chart</button>
            <button onclick="loadTrends()">Load Trends</button>
            <button onclick="connectWebSocket()">Connect Live</button>
            <button onclick="showAdminPanel()">Admin Panel</button>
        </div>

        <div id="adminPanel" style="display: none; background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
            <h3>Admin Panel</h3>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;">
                <button onclick="cleanDatabase()" style="background: #dc3545;">Clean Database</button>
                <button onclick="restartGapFilling()">Restart Gap Filling</button>
                <button onclick="restartServices()">Restart Services</button>
                <button onclick="getDatabaseStatus()">Database Status</button>
                <button onclick="getGapFillingStatus()">Gap Filling Status</button>
                <button onclick="cleanSymbol()">Clean Symbol</button>
            </div>
            <div id="adminResults" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 4px; display: none;"></div>
        </div>

        <div id="status" class="status" style="display: none;"></div>

        <div class="grid">
            <div class="chart-container">
                <h3>Price Chart with ML Predictions</h3>
                <div class="chart-wrapper">
                    <canvas id="priceChart"></canvas>
                </div>
            </div>

            <div class="chart-container">
                <h3>Accuracy Trends</h3>
                <div class="trends-wrapper">
                    <canvas id="trendsChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let priceChart = null;
        let trendsChart = null;
        let ws = null;
        let API_BASE = 'http://localhost:8000/api';
        let WS_BASE = 'ws://localhost:8000/ws';

        function updateEnvironment() {
            const env = document.getElementById('environmentSelect').value;
            if (env === 'railway') {
                API_BASE = 'https://lavish-peace-production.up.railway.app/api';
                WS_BASE = 'wss://lavish-peace-production.up.railway.app/ws';
            } else {
                API_BASE = 'http://localhost:8000/api';
                WS_BASE = 'ws://localhost:8000/ws';
            }
            showStatus(`Switched to ${env === 'railway' ? 'Railway Production' : 'Localhost'}`, 'success');
        }

        function showStatus(message, type = 'success') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            setTimeout(() => status.style.display = 'none', 3000);
        }

        async function loadChart() {
            const symbol = document.getElementById('symbolInput').value.toUpperCase();
            const timeframe = document.getElementById('timeframeSelect').value;
            
            try {
                showStatus(`Loading ${symbol} chart...`, 'success');
                const response = await fetch(`${API_BASE}/asset/${symbol}/forecast?timeframe=${timeframe}`);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                drawPriceChart(data, symbol, timeframe);
                showStatus(`${symbol} chart loaded successfully`, 'success');
            } catch (error) {
                showStatus(`Error loading chart: ${error.message}`, 'error');
            }
        }

        async function loadTrends() {
            const symbol = document.getElementById('symbolInput').value.toUpperCase();
            const timeframe = document.getElementById('timeframeSelect').value;
            
            try {
                showStatus(`Loading ${symbol} trends...`, 'success');
                console.log(`🔍 Loading trends for ${symbol} ${timeframe}`);
                const response = await fetch(`${API_BASE}/asset/${symbol}/trends?timeframe=${timeframe}`);
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                console.log('📊 Trends API Response:', data);
                console.log('📈 Accuracy History:', data.accuracy_history);
                drawTrendsChart(data, symbol, timeframe);
                showStatus(`${symbol} trends loaded successfully`, 'success');
            } catch (error) {
                console.error('❌ Trends loading error:', error);
                showStatus(`Error loading trends: ${error.message}`, 'error');
            }
        }

        function drawPriceChart(data, symbol, timeframe) {
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            if (priceChart) priceChart.destroy();

            // Timeframe-specific configurations
            const timeframeConfigs = {
                '1h': { past: 24, future: 12, total: 36 },
                '4H': { past: 24, future: 6, total: 30 },
                '1D': { past: 30, future: 7, total: 37 },
                '7D': { past: 30, future: 7, total: 37 },
                '1W': { past: 12, future: 4, total: 16 },
                '1M': { past: 30, future: 7, total: 37 }
            };
            
            const config = timeframeConfigs[timeframe] || { past: 30, future: 7, total: 37 };
            console.log(`📊 Chart config for ${timeframe}:`, config);

            // Use chart data from API response
            const pastData = data.chart?.past || [];
            const futureData = data.chart?.future || [];
            const timestamps = data.chart?.timestamps || [];
            
            // Limit data to timeframe configuration
            const pastPrices = pastData.slice(-config.past);
            const futurePrices = futureData.slice(0, config.future);
            const allTimestamps = timestamps.slice(0, config.total);
            
            const labels = allTimestamps.map(ts => new Date(ts).toLocaleTimeString());
            const allPrices = [...pastPrices, ...futurePrices];

            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${symbol} Historical`,
                        data: pastPrices,
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 3
                    }, {
                        label: 'ML Predictions',
                        data: [...Array(config.past).fill(null), ...futurePrices],
                        borderColor: '#ff6b9d',
                        backgroundColor: 'rgba(255, 107, 157, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1,
                        pointStyle: 'circle',
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: { display: true, text: 'Price ($)' }
                        },
                        x: {
                            title: { display: true, text: 'Time' }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        title: {
                            display: true,
                            text: `${symbol} Chart (${timeframe}) - ${config.past} past + ${config.future} future points`
                        }
                    }
                }
            });
        }

        function drawTrendsChart(data, symbol, timeframe) {
            const ctx = document.getElementById('trendsChart').getContext('2d');
            
            if (trendsChart) trendsChart.destroy();

            const history = data.accuracy_history || [];
            console.log('📊 Drawing trends chart with history:', history);
            console.log('📊 History length:', history.length);
            
            const labels = history.map(h => h.date);
            const actualPrices = history.map(h => h.actual);
            const predictedPrices = history.map(h => h.predicted);
            const results = history.map(h => h.result === 'Hit' ? 1 : 0);
            
            console.log('📊 Chart data - Labels:', labels);
            console.log('📊 Chart data - Actual prices:', actualPrices);
            console.log('📊 Chart data - Predicted prices:', predictedPrices);
            console.log('📊 Chart data - Results:', results);

            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Actual Price',
                        data: actualPrices,
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.1
                    }, {
                        label: 'Predicted Price',
                        data: predictedPrices,
                        borderColor: '#ff6b9d',
                        backgroundColor: 'rgba(255, 107, 157, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: 'Price ($)' }
                        },
                        x: {
                            title: { display: true, text: 'Date' }
                        }
                    },
                    plugins: {
                        legend: { display: true, position: 'top' },
                        title: {
                            display: true,
                            text: `${symbol} Accuracy Trends (${timeframe})`
                        }
                    }
                }
            });
            
            console.log('📊 Trends chart created:', trendsChart);
        }

        function connectWebSocket() {
            const symbol = document.getElementById('symbolInput').value.toUpperCase();
            
            if (ws) {
                ws.close();
                ws = null;
                showStatus('WebSocket disconnected', 'error');
                return;
            }

            try {
                ws = new WebSocket(`${WS_BASE}/chart/${symbol}`);
                
                ws.onopen = () => {
                    showStatus(`Connected to ${symbol} live stream`, 'success');
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    updateChartRealtime(data);
                };
                
                ws.onclose = () => {
                    showStatus('WebSocket connection closed', 'error');
                    ws = null;
                };
                
                ws.onerror = (error) => {
                    showStatus('WebSocket error occurred', 'error');
                    ws = null;
                };
            } catch (error) {
                showStatus(`WebSocket connection failed: ${error.message}`, 'error');
            }
        }

        function updateChartRealtime(data) {
            if (!priceChart) return;

            const newTime = new Date(data.timestamp).toLocaleTimeString();
            const newPrice = data.price;

            // Add new data point
            priceChart.data.labels.push(newTime);
            priceChart.data.datasets[0].data.push(newPrice);

            // Keep only last 50 points
            if (priceChart.data.labels.length > 50) {
                priceChart.data.labels.shift();
                priceChart.data.datasets[0].data.shift();
            }

            priceChart.update('none');
        }

        // Setup event listeners on page load
        window.onload = () => {
            // Don't auto-load charts on refresh
        };

        // Admin Panel Functions
        function showAdminPanel() {
            const panel = document.getElementById('adminPanel');
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
        }

        function showAdminResult(message, type = 'success') {
            const results = document.getElementById('adminResults');
            results.innerHTML = `<div class="${type}">${message}</div>`;
            results.style.display = 'block';
        }

        async function cleanDatabase() {
            if (!confirm('This will delete ALL database records. Continue?')) return;
            try {
                const response = await fetch(`${API_BASE}/admin/database/clean`, { method: 'POST' });
                const data = await response.json();
                showAdminResult(data.success ? data.message : data.error, data.success ? 'success' : 'error');
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        async function restartGapFilling() {
            try {
                const response = await fetch(`${API_BASE}/admin/gap-filling/restart`, { method: 'POST' });
                const data = await response.json();
                showAdminResult(data.success ? data.message : data.error, data.success ? 'success' : 'error');
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        async function restartServices() {
            try {
                const response = await fetch(`${API_BASE}/admin/services/restart`, { method: 'POST' });
                const data = await response.json();
                showAdminResult(data.success ? data.message : data.error, data.success ? 'success' : 'error');
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        async function getDatabaseStatus() {
            try {
                const response = await fetch(`${API_BASE}/admin/database/status`);
                const data = await response.json();
                if (data.success) {
                    const msg = `Records: Actual=${data.tables.actual_prices}, Forecasts=${data.tables.forecasts}, Accuracy=${data.tables.forecast_accuracy}`;
                    showAdminResult(msg, 'success');
                } else {
                    showAdminResult(data.error, 'error');
                }
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        async function getGapFillingStatus() {
            try {
                const response = await fetch(`${API_BASE}/admin/gap-filling/status`);
                const data = await response.json();
                if (data.success) {
                    const msg = `Recent insertions: ${data.recent_insertions}, Coverage: ${data.coverage_percentage}% (${data.total_symbols_with_data}/${data.expected_symbols})`;
                    showAdminResult(msg, 'success');
                } else {
                    showAdminResult(data.error, 'error');
                }
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        async function cleanSymbol() {
            const symbol = document.getElementById('symbolInput').value.toUpperCase();
            if (!symbol || !confirm(`Delete all data for ${symbol}?`)) return;
            try {
                const response = await fetch(`${API_BASE}/admin/database/symbol/${symbol}`, { method: 'DELETE' });
                const data = await response.json();
                showAdminResult(data.success ? `Deleted ${data.deleted_records} records for ${symbol}` : data.error, data.success ? 'success' : 'error');
            } catch (error) {
                showAdminResult(`Error: ${error.message}`, 'error');
            }
        }

        // Cleanup WebSocket on page unload
        window.onbeforeunload = () => {
            if (ws) ws.close();
        };
    </script>
</body>
</html>